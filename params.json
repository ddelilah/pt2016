{
  "name": "Programming Techniques 2016",
  "tagline": "",
  "body": "* [Note si prezente](https://docs.google.com/spreadsheets/d/1drC3oaRD4cXoczMXuruCqlA25Szm3BQF9uzW1bfbFiE/edit?usp=sharing)\r\n* [Model documentatie](https://drive.google.com/open?id=0B65xsfFmMCpAem55UDVUMVAtUjQ)\r\n\r\n### Barem Tema 3\r\n\r\nRequirement: Design and implement a simulation application aiming to analyze queuing based systems for determining and minimizing clients’ waiting time.\r\nInput data: \r\n+ Minimum and maximum interval of arriving time between clients\r\n+ Minimum and maximum service time\r\n+ Number of queues\r\n+ Simulation interval\r\n+ Other information you may consider necessary\r\nMinimal output: \r\n+ Average of waiting time, service time and empty queue time for 1, 2 and 3 queues for the simulation interval and for a specified interval\r\n+ Log of events and main system data\r\n+ Queue evolution\r\n+ Peak hour for the simulation interval\r\n\r\nBarem :\r\n\r\n+ Documentatie - 1p\r\n+ Cel putin un thread sau timer care sa ruleze logica aplicatiei - 1p\r\n+ Log of events (Logger, Output File sau TextArea pe fereastra) - 1p\r\n+ Queue evolution (console) - 1p / Interfata grafica – Queue evolution - 2p\r\n+ Input de la tastatura / fisier (nu harcoded) – 1 punct\r\n+ Multithreading: 1 thread pentru fiecare Queue – 3 puncte\r\n+ Average of waiting time (0,33p), service time (0,33p), peak hour (0,33p) - afisate la finalul simularii\r\n\r\nTutoriale\r\n+ Java Concurrency in practice www.cs.unicam.it/culmone/?download=java_concurrency_in_practice.pdf\r\n+ http://docs.oracle.com/javase/tutorial/essential/concurrency/index.html\r\n+ http://www.tutorialspoint.com/java/util/timer_schedule_period.htm\r\n+ http://www.javacodegeeks.com/2013/01/java-thread-pool-example-using-executors-and-threadpoolexecutor.html\r\n+ http://javahash.com/java-concurrency-future-callable-executor-example/\r\n\r\n\r\n### Feedback Form\r\nIn functie de cum/cand aveti 5 minute, va rog sa completati formularul de feedback de mai jos. Raspunsurile sunt anonime, asa ca puteti scrie fara nicio grija :) Va multumesc!\r\n\r\n[Formular de feedback](http://goo.gl/forms/pUol99mZi6)\r\n\r\n### Diagrame Sequence & Activity\r\n\r\n**Diagramele sequence** arata modul si ordinea in care interactioneaza procesele si durata de viata a obiectelor implicate. Se realizeaza atunci cand avem deja o arhitectură bine definita si dorim sa mapam functionalitatea unui use case pe implementarea curenta.\r\n\r\nElementele unei diagrame UML Sequence sunt:\r\n\r\n   * mesaje: reprezentate prin sageți de la un obiect la altul = metodele utilizate sau mesajele transmise. Mesajele de răspuns au orientare opusă și se reprezintă cu linie punctata.\r\n   * execuții: reprezentate prin dreptunghiuri care reprezinta durata de viata a unei executii\r\n   * obiecte: obiectele sunt reprezentate in partea de sus a diagramei, prin dreptunghuri avand numele clasei din care fac parte\r\n   * linii de executie: se reprezinta cu linie punctata si arata durata de viata a obiectelor\r\n\r\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/9/9b/CheckEmail.svg/440px-CheckEmail.svg.png)\r\n\r\n**Diagramele activity** arata executia pas cu pas a unei functionalitați, reprezentand toate caile prin care se poate ajunge la finalul executiei unui use case. Sunt construite din forme predefinite si sageti, cele mai importante forme fiind:\r\n\r\n   * dreptunghiuri rotunjite pentru actiuni\r\n   * romburi pentru decizii\r\n   * dungi negre pentru inceperea/terminarea mai multor activitati concurente\r\n   * bulina neagra pentru starea initiala\r\n   * bulina neagra încercuita pentru starea finala\r\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/e/e7/Activity_conducting.svg/440px-Activity_conducting.svg.png)\r\n\r\n### Barem Tema 2\r\nRequirement: Consider an application OrderManagement for processing customer orders. The application uses (minimally) the following classes: Order, OPDept (Order Processing Department), Customer, Product, and Warehouse. The classes OPDept and Warehouse use a BinarySearchTree for storing orders.\r\n+ a. Analyze the application domain, determine the structure and behavior of its classes, identify use cases.\r\n+ b. Generate use case diagrams, an extended UML class diagram, two sequence diagrams and an activity diagram.\r\n+ c. Implement and test the application classes. Use javadoc for documenting the classes.\r\n+ d. Design, write and test a Java program for order management using the classes designed at question c). The program should include a set of utility operations such as under-stock, over-stock, totals, filters, etc.\r\n\r\n    * respectarea claselor minimale din enuntul problemei si folosirea BST - 1p\r\n    * admin view si regular user view - 1p\r\n    * operatii admin (ex: adaugare/stergere de produse - 1p, modificarea stocului - 1p)\r\n    * operatii user normal (filtrare produse - 1p, plasare comenzi - 1p, pastrare si vizualizare istoric comenzi - 1p)\r\n    * documentatie - 3p  \r\n\r\n### Tema 1\r\nVa rog sa puneti pe Github pana cel tarziu luni (14.03) prima tema + documentatie toti cei care ati fost notati vineri.\r\n\r\n### Internship Program\r\nZau ca nu fac reclama, dar daca va intereseaza un internship vara aceasta, recomand cu caldura.\r\n\r\n![ISDC internship](https://scontent.ftsr1-1.fna.fbcdn.net/hphotos-xfl1/t31.0-8/s960x960/12795233_941022662620362_3530209250674346819_o.jpg)\r\n\r\n### Git Help - pushing to a remote repository\r\nDin cate am observat, unii dintre voi aveti probleme cu Git-ul asa ca va sugerez sa cititi [urmatoarea sectiune](https://help.github.com/articles/adding-a-file-to-a-repository-from-the-command-line/) si sa incercati apoi sa faceti push din nou (folosind Git Bash). \r\n\r\n### Reguli Laborator PT\r\n\r\n* prezenta\r\n    * participarea la toate laboratoarele este obligatorie \r\n    * se accepta maxim 3 absente in situatii exceptionale (daca sunt anuntata inainte)\r\n\r\n* teme\r\n    * 5 teme cu predare din 2 in 2 saptamani\r\n    * fiecare saptamana de delay => -1p la nota finala a temei respective\r\n    * intr-un laborator se poate preda o singura tema restanta\r\n    * in saptamana premergatoare sesiunii se poate preda o singura tema restanta\r\n    * exista posibilitatea obtinerii unor bonusuri anuntate pe parcursul semestrului\r\n\r\n* predarea temelor\r\n    * codul sursa\r\n    * javadoc pe clasa si pe metodele cu logica de business\r\n    * documentatie (3000 de cuvinte, accent pe diagrame: use case, class & sequence) avand structura\r\n        * Obiectivul temei\r\n        * Analiza problemei, modelare, scenarii, cazuri de utilizare\r\n        * Proiectare (diagrame UML, structuri de date, proiectare clase, interfete, relatii, packages, algoritmi, interfata utilizator)\r\n        * Implementare si testare\r\n        * Rezultate\r\n        * Concluzii, ce s-a invatat din tema, dezvoltari ulterioare\r\n        * Bibliografie\r\n    * la predare, veti primi o intrebare intrebare legata de tema (fie pe baza codului, fie pe baza documentatiei)\r\n\r\n* `    if (labFinalGrade >= 5 && attendances >= 11) {\r\n           return \"pass\"; \r\n       } else {\r\n           return \"fail\";\r\n       }`\r\n\r\n\r\n### Barem Tema 1\r\nRequirement: Propose, design and implement a system for polynomial processing. Consider the polynomials of one variable and integer coefficients.\r\n\r\n   * documentatie - 2p\r\n   * interfata grafica - 1p\r\n   * adunare - 1p\r\n   * scadere - 1p\r\n   * inmultire - 1.5p\r\n   * impartire - 1.5p\r\n   * integrare si derivare / graficul functiei / calculul radacinilor- 2p\r\n\r\n### Clean code conventions\r\n\"Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live. Code for readability.\"\r\n\r\n   Clean code can be achieved by \r\n   * meaningful names (please see ch. 9 of the recommended reading material)\r\n      * pronounceable, searchable, avoid encodings\r\n      * intention-revealing names\r\n   * language fundamentals (please see ch. 10.1 of the recommended reading material)\r\n      * minimize the accessibility of classes and members (use encapsulation)\r\n   * methods\r\n      * small, easy to read & understand\r\n      * do exactly one thing\r\n      * keep number of arguments minimal & justified \r\n   * objects & data (Law of Demeter <https://en.wikipedia.org/wiki/Law_of_Demeter>)\r\n     * keep the variables private when you don't want anyone to depend on them\r\n     * hide implementation, expose interface\r\n     * \"talk to friends, not strangers\":\r\n        * a method `f` of class `C` should only call methods of:\r\n            * `C`\r\n            * objects created by `f`\r\n            * objects passed as an argument of `f`\r\n            * objects held in an instance of `C`\r\n        * a method should NOT invoke methods on objects that are returned by any allowed functions\r\n   * formatting (please see ch 4, 6 and 7 of the recommended reading material)\r\n   * comments (please see ch. 5 of the recommended reading material)\r\n       * explain your intend, but avoid noisy or redundant comments\r\n   * exceptions & error handling\r\n       * have a clear separation between error handling and business logic (define a normal flow and the exceptional flows)\r\n       * avoid returning/passing `null` in case of exceptions (difficult to handle) - thrown an exception instead\r\n       * provide context (informative messages) with exceptions\r\n\r\nClean code should obey the following principles:\r\n   * single responsibility & high cohesion\r\n       * specialized classes/methods\r\n       * keep modules/elements together\r\n   * low coupling\r\n       * minimize dependencies\r\n\r\nRecommended reading: <https://oracle.com/technetwork/java/codeconventions-150003.pdf>\r\n\r\n\r\n\r\n\r\n",
  "google": "UA-74401060-1",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}